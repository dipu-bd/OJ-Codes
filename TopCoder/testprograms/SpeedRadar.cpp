/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
//C headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>
//cpp headers
#include <iostream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <deque>
#include <list>
#include <bitset>
using namespace std;
//typedefs
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vii;
//some constants
const double PI = 2.0 * acos(0.0);
const double E = exp(1);
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
//useful with graphs
#define _a first
#define _b second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define _IT ::iterator
#define all(v) v.begin(), v.end()
#define ssort(v) stable_sort(all(v))
#define loop(typ,it,v) for(typ::iterator it = v.begin(); it != v.end(); ++it)
#define rloop(typ,it,v) for(typ::reverse_iterator it = v.rbegin(); it != v.rend(); ++it)
#define cloop(typ,it,v) for(typ::const_iterator it = v.begin(); it != v.end(); ++it)
#define rcloop(typ,it,v) for(typ::const_reverse_iterator it = v.rbegin(); it != v.rend(); ++it)


class SpeedRadar
{
public:
    double averageSpeed(int minLimit, int maxLimit, vector <int> readings)
    {
        int cnt = 0;
        double fault = 0;
        double sum = 0.0;
        loop(vector<int>, it, readings)
        {
            if((*it) < minLimit) fault++;
            else if((*it) > maxLimit) fault++;
            else
            {
                sum += *it;
                cnt++;
            }
        }

        fault = (fault * 100.0) / readings.size();
        if(fault > 10.0) return 0.0;

        sum /= cnt;
        return sum;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <int> p2, bool hasAnswer, double p3)
{
    cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
    for (int i = 0; int(p2.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p2[i];
    }
    cout << "}";
    cout << "]" << endl;
    SpeedRadar *obj;
    double answer;
    obj = new SpeedRadar();
    clock_t startTime = clock();
    answer = obj->averageSpeed(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == answer && fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    int p0;
    int p1;
    vector <int> p2;
    double p3;

    {
        // ----- test 0 -----
        p0 = 1;
        p1 = 50;
        int t2[] = {45, 40, 50};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 45.0;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = 1;
        p1 = 50;
        int t2[] = {42, 43, 44, 45, 46, 47, 48, 49, 50, 51};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 46.0;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = 1;
        p1 = 50;
        int t2[] = {42, 46, 48, 50, 52};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 0.0;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = 20;
        p1 = 60;
        int t2[] = {25, 45, 45, 43, 24, 9, 51, 55, 60, 34, 61, 23, 40, 40, 47, 49, 33, 23, 47, 54, 54};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        p3 = 41.68421052631579;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// A speed radar is installed in a highway zone where the maximum speed limit is maxLimit mph, and the minimum speed limit is minLimit mph.  Any reading that is strictly above or below this interval is an infringement.
//
//
// Periodically, the radar readings are analyzed to make sure that the sensors are working properly.  It is assumed that most drivers obey speed limits, and therefore, the radar will be considered faulty if more than 10% of its readings are infringements.
//
//
// Given the radar readings over a period of time, return the average speed of all cars that are driving within the speed limits.  If the radar is faulty, return 0.0.
//
//
// DEFINITION
// Class:SpeedRadar
// Method:averageSpeed
// Parameters:int, int, vector <int>
// Returns:double
// Method signature:double averageSpeed(int minLimit, int maxLimit, vector <int> readings)
//
//
// NOTES
// -The returned value must be accurate to within a relative or absolute value of 1E-9.
//
//
// CONSTRAINTS
// -maxLimit will be between 1 and 200, inclusive.
// -minLimit will be between 1 and maxLimit, inclusive.
// -readings will contain between 1 and 50 elements, inclusive.
// -Each element of readings will be between 1 and 200, inclusive.
//
//
// EXAMPLES
//
// 0)
// 1
// 50
// {45, 40, 50}
//
// Returns: 45.0
//
// With all drivers within the speed limits, the return value is just the average speed.
//
// 1)
// 1
// 50
// {42,43,44,45,46,47,48,49,50,51}
//
// Returns: 46.0
//
// There is only one driver infringing the limit, and it represents 10% of the total readings. The average speed of the other readings is 46.0.
//
// 2)
// 1
// 50
// {42,46,48,50,52}
//
// Returns: 0.0
//
// Only one reading is outside the given limits, but it represents 20% of the total number of readings.  We therefore assume that the radar is not working and return 0.0.
//
// 3)
// 20
// 60
// {25,45,45,43,24,9,51,55,60,34,61,23,40,40,47,49,33,23,47,54,54}
//
// Returns: 41.68421052631579
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
