/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
//C headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
//cpp headers
#include <iostream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <deque>
#include <list>
//#include <bitset>
using namespace std;
//typedefs
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vii;
typedef vector<pii> vpii;
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define memsz(a,b,n) memset(a, b, n * sizeof(*a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
#define sf1(a) scanf("%d", &a)
#define sf2(a, b) scanf("%d %d", &a, &b)
#define sf3(a, b, c) scanf("%d %d %d", &a, &b, &c);
#define sf4(a, b, c, d) scanf("%d %d %d %d", &a, &b, &c, &d);
//useful with graphs
#define fr first
#define sc second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define ins insert
#define IT iterator
#define allof(v) v.begin(), v.end()
#define ssort(v) stable_sort(v.begin(), v.end())
#define LB lower_bound
#define UB upper_bound
#define POPC __builtin_popcount
#define loop(i, x) for(__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)
#define rloop(i, x) for(__typeof((x).rbegin()) i=(x).rbegin(); i!=(x).rend(); ++i)
//variables and functions
const double PI = 2.0 * acos(0.0);
const double EXP1 = exp(1);
template<typename T> inline T sqr(T n) { return n * n; }
inline double hypot(double x, double y) { return sqrt(sqr(x) + sqr(y)); }
template<typename T> inline T pmod(T n, T m) { return ((n % m) + m) % m; }
/*--------------------------------------------------------------------------------*/

class SymbolFrequency
{
public:
    double language(vector <string> frequencies, vector <string> text)
    {
        //get real frequencies
        int totsize = 0;
        map<char, int> realCount;
        loop(s, text)
        {
            loop(c, *s)
            {
                if(islower(*c))
                {
                    ++realCount[*c];
                    ++totsize;
                }
            }
        }

        double res = INT_MAX;
        loop(it, frequencies)
        {
            //parse frequencies
            map<char, double> expCount;
            const char* data = it->data();
            for(int i = 2; i < it->size(); i += 3)
            {
                char ch = data[i - 2];
                int val = data[i - 1] * 10 + data[i] - (11 * '0');
                expCount[ch] = val / 100.0;
            }

            //get deviation
            double deviation = 0;
            loop(f, expCount)
            {
                double account = realCount[f->fr];
                double excount = totsize * f->sc;
                deviation += sqr(excount - account);
            }
            loop(f, realCount)
            {
                if(expCount.count(f->fr)) continue;
                double account = f->sc;
                double excount = totsize * expCount[f->fr];
                deviation += sqr(excount - account);
            }

            if(deviation < res) res = deviation;
        }

        return res;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SymbolFrequency *obj;
	double answer;
	obj = new SymbolFrequency();
	clock_t startTime = clock();
	answer = obj->language(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	double p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"a30b30c40","a20b40c40"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"aa bbbb cccc"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0.0;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"a30b30c40","a20b40c40"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"aaa bbbb ccc"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"a10b10c10d10e10f50"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"abcde g"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 10.8;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"a09b01c03d05e20g01h01i08l06n08o06r07s09t08u07x01","a14b02c05d06e15g01h01i07l05n07o10r08s09t05u04x01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"this text is in english","the letter counts should be close to","that in the table"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 130.6578;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"a09b01c03d05e20g01h01i08l06n08o06r07s09t08u07x01","a14b02c05d06e15g01h01i07l05n07o10r08s09t05u04x01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"en esta es una oracion en castellano","las ocurrencias de cada letra","deberian ser cercanas a las dadas en la tabla"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 114.9472;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"z99y01","z99y01","z99y01","z99y01","z99y01","z99y01","z99y01","z99y01","z99y01","z99y01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 495050.0;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// In written languages, some symbols may appear more often than others.  
// Expected frequency tables have been defined for many languages.  
// For each symbol in a language, a frequency table will contain its expected percentage in a typical passage written in that language.  
// For example, if the symbol "a" has an expected percentage of 5, then 5% of the letters in a typical passage will be "a". If a passage contains 350 letters, then 'a' has an expected count of 17.5 for that passage (17.5 = 350 * 5%). Please note that the expected count can be a non-integer value.
// 
// 
// The deviation of a text with respect to a language frequency table can be computed in the following manner.  
// For each letter ('a'-'z') determine the difference between the expected count and the actual count in the text.  
// The deviation is the sum of the squares of these differences.  
// Blank spaces (' ') and line breaks (each element of text is a line) are ignored when calculating percentages.
// 
// 
// Each frequency table will be described as a concatenation of up to 16 strings of the form "ANN", 
// where A is a lowercase letter ('a'-'z') and NN its expected frequency as a two-digit percentage between "00" (meaning 0%) and "99" (meaning 99%), inclusive. 
// Any letter not appearing in a table is not expected to appear in a typical passage (0%).
// You are given a vector <string> frequencies of frequency tables of different languages.  
// Return the lowest deviation the given text has with respect to the frequency tables.
// 
// 
// DEFINITION
// Class:SymbolFrequency
// Method:language
// Parameters:vector <string>, vector <string>
// Returns:double
// Method signature:double language(vector <string> frequencies, vector <string> text)
// 
// 
// NOTES
// -The returned value must be accurate to within a relative or absolute value of 1E-9.
// 
// 
// CONSTRAINTS
// -frequencies will contain between 1 and 10 elements, inclusive.
// -Each element of frequencies will be formatted as described in the statement.
// -Each element of frequencies will contain between 6 and 48 characters, inclusive.
// -No letter will appear twice in the same element of frequencies.
// -The sum of the percentages in each element of frequencies will be equal to 100.
// -text will contain between 1 and 10 elements, inclusive.
// -Each element of text will contain between 1 and 50 characters, inclusive.
// -Each element of text will contain only lowercase letters ('a'-'z') and spaces (' ').
// -text will have at least one non-space character.
// 
// 
// EXAMPLES
// 
// 0)
// {"a30b30c40","a20b40c40"}
// {"aa bbbb cccc"}
// 
// Returns: 0.0
// 
// The first table indicates that 30% of the letters are expected to be 'a', 30% to be 'b', and 40% to be 'c'.  The second table indicates that 20% are expected to be 'a', 40% to be 'b', and 40% to be 'c'.
// We consider the text to have length 10, as blank spaces are ignored.
// 
// With respect to the first table, there are 2 'a' where 3 were expected (a difference of 1), one more 'b' than expected (again a difference of 1) and as many 'c' as expected. 
// The sum of the squares of those numbers gives a deviation of 2.0.
// 
// As for the second table, the text matches expected counts exactly, so its deviation with respect to that language is 0.0. 
// 
// 
// 1)
// {"a30b30c40","a20b40c40"}
// {"aaa bbbb ccc"}
// 
// Returns: 2.0
// 
// Here we use the same tables as in the previous example, but with a different text. 
// The counts for 'b' and 'c' each differ by 1 from the expected counts in the first table, and the counts for 'a' and 'c' each differ by 1 from the expected counts in the second table.
// The text has a deviation of 2.0 with respect to both tables.
// 
// 
// 2)
// {"a10b10c10d10e10f50"}
// {"abcde g"}
// 
// Returns: 10.8
// 
// Here, each of the letters 'a' through 'e' is expected to make up 10% of the letters (0.6 letters).  Each of those letters actually appears once, so the difference is 0.4, which becomes 0.16 when squared.  50% of the letters (3 letters) are expected to be 'f', but 'f' does not appear at all.  The square of this difference is 9.0.  No 'g's are expected to appear, but there is one in the text.  This adds 1.0 to the deviation.  The final deviation for this table is: 0.16+0.16+0.16+0.16+0.16+9.0+1.0=10.8.
// 
// 3)
// {"a09b01c03d05e20g01h01i08l06n08o06r07s09t08u07x01"
// ,"a14b02c05d06e15g01h01i07l05n07o10r08s09t05u04x01"}
// {"this text is in english" 
// ,"the letter counts should be close to"
// ,"that in the table"}
// 
// Returns: 130.6578
// 
// These two frequency tables correspond (roughly) to the frequencies found in the English and Spanish languages, respectively. The English passage, as expected, has a lower deviation in the first table than in the second one.
// 
// 4)
// {"a09b01c03d05e20g01h01i08l06n08o06r07s09t08u07x01"
// ,"a14b02c05d06e15g01h01i07l05n07o10r08s09t05u04x01"}
// {"en esta es una oracion en castellano"
// ,"las ocurrencias de cada letra"
// ,"deberian ser cercanas a las dadas en la tabla"}
// 
// Returns: 114.9472
// 
// The same tables again, but with Spanish passage. This time the second table, which correspond to frequencies in Spanish, gives the lowest deviation.
// 
// 5)
// {"z99y01", "z99y01", "z99y01", "z99y01", "z99y01", 
//  "z99y01", "z99y01", "z99y01", "z99y01", "z99y01"}
// {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
//  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
// 
// Returns: 495050.0
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
