/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
#include <bits/stdc++.h>
using namespace std;
//typedefs
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vii;
typedef vector<pii> vpii;
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define memsz(a,b,n) memset(a, b, n * sizeof(*a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
#define sf1(a) scanf("%d", &a)
#define sf2(a, b) scanf("%d %d", &a, &b)
#define sf3(a, b, c) scanf("%d %d %d", &a, &b, &c);
#define sf4(a, b, c, d) scanf("%d %d %d %d", &a, &b, &c, &d);
//useful with graphs
#define fr first
#define sc second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define ins insert
#define IT iterator
#define allof(v) v.begin(), v.end()
#define ssort(v) stable_sort(v.begin(), v.end())
#define LB lower_bound
#define UB upper_bound
#define POPC __builtin_popcount
#define loop(i, x) for(__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)
#define rloop(i, x) for(__typeof((x).rbegin()) i=(x).rbegin(); i!=(x).rend(); ++i)
//variables and functions
const double PI = 2.0 * acos(0.0);
const double EXP1 = exp(1);
template<typename T> inline T sqr(T n) { return n * n; }
inline double hypot(double x, double y) { return sqrt(sqr(x) + sqr(y)); }
template<typename T> inline T pmod(T n, T m) { return ((n % m) + m) % m; }
/*--------------------------------------------------------------------------------*/

pii s;
int m, n;
vpii star;
int dis[55][55];
bool vis[55][55];

int X[] = {0, 0, 1, -1};
int Y[] = {1, -1, 0, 0};

void BFS(vector<string>& board)
{
    clr(vis);
    queue<pii> q;
    q.push(s);
    dis[s.fr][s.sc] = 0;
    vis[s.fr][s.sc] = 1;
    while(q.size())
    {
        int x = q.front().fr;
        int y = q.front().sc;
        q.pop();

        REP(i, 0, 4)
        {
            int a = x + X[i];
            int b = y + Y[i];
            if(a < 0 || b < 0 || a >= m || b >= n) continue;
            if(board[a][b] != '#' && !vis[a][b])
            {
                vis[a][b] = 1;
                q.push(make_pair(a, b));
                dis[a][b] = dis[x][y] + 1;
            }
        }
    }
}

class RobotOnMoon {
public:
	int longestSafeCommand(vector <string> board) {
        star.clear();
		m = board.size();
		n = board[0].size();
		REP(i, 0, m)
		REP(j, 0, n)
		{
			if(board[i][j] == 'S')
            {
                s = mp(i, j);
            }
			else if(board[i][j] == '#')
			{
				star.pb(mp(i, j));
			}
		}

		if(star.empty())
		{
			return max(s.fr, m - s.fr - 1) + max(s.sc, n - s.sc - 1);
		}

        BFS(board);

        int md = 0;
		loop(it, star)
		{
		    int bd = dis[it->fr][it->sc];
            int pd = abs(it->fr - s.fr) + abs(s.sc - it->sc);
            if(pd == bd)
            {
                if(it->fr == s.fr || it->sc == s.sc)
                    return -1;
            }
            md = max(md, bd);
		}

		return md;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	RobotOnMoon *obj;
	int answer;
	obj = new RobotOnMoon();
	clock_t startTime = clock();
	answer = obj->longestSafeCommand(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	int p1;

	{
	// ----- test 0 -----
	string t0[] = {"#####","#...#","#.S.#","#...#","#####"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	string t0[] = {"S......"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	string t0[] = {"#.######","#.#..S.#","#.#.##.#","#......#","########"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	string t0[] = {"S"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// There is a robot on the moon.
// You are given a vector <string> board containing the map of a rectangular area.
// The robot is currently located somewhere in that area.
// In the map, the character '.' (period) represents an empty square, 'S' represents an empty square that currently contains the robot, and '#' represents an obstacle.
//
//
// We are going to send a sequence of commands to the robot.
// Each command must be one of 'U', 'D', 'L', and 'R', representing a step up, down, left, and right, respectively.
//
//
// Whenever the robot receives a command, one of three things will happen:
//
// If the requested move leads to an empty square, the robot performs the move.
// If the requested move leads to a square with an obstacle, the robot ignores the command and remains in place.
// If the requested move leads out of the mapped area, the robot leaves the mapped area and dies immediately.
//
//
//
// A sequence of commands is called safe if the robot is still alive after executing the entire sequence.
//
//
// When sending commands to the moon, some of them may get lost along the way.
// This may sometimes change a safe sequence of commands into an unsafe one.
// We want to avoid that.
//
//
// A sequence of commands is called perfectly safe if it is safe, and each of its subsequences is safe as well.
// (Note that this includes subsequences that are not contiguous.)
//
//
// Find and return the largest X such that there is a perfectly safe sequence of X commands.
// If there are arbitrarily long perfectly safe sequences, return -1 instead.
//
// DEFINITION
// Class:RobotOnMoon
// Method:longestSafeCommand
// Parameters:vector <string>
// Returns:int
// Method signature:int longestSafeCommand(vector <string> board)
//
//
// NOTES
// -The direction 'U' corresponds to moving from board[i][j] to board[i-1][j]. The direction 'L' corresponds to moving from board[i][j] to board[i][j-1].
//
//
// CONSTRAINTS
// -board will contain between 1 and 50 elements, inclusive.
// -Each element of board will contain between 1 and 50 characters.
// -Each element of board will contain same number of characters.
// -The characters in board will be '.', '#' or 'S'.
// -There will be exactly one 'S' in board.
//
//
// EXAMPLES
//
// 0)
// {"#####",
//  "#...#",
//  "#.S.#",
//  "#...#",
//  "#####"}
//
// Returns: -1
//
// There are obstacles all around the map. This means that all possible sequences of commands are perfectly safe.
//
// 1)
// {"S......"}
//
// Returns: 6
//
// The longest perfectly safe string is "RRRRRR"
//
// 2)
// {"#.######",
//  "#.#..S.#",
//  "#.#.##.#",
//  "#......#",
//  "########"}
//
// Returns: -1
//
// Even though it is possible to leave this map, there are still arbitrarily long perfectly safe sequences of commands. For example, any sequence that does not contain any 'U' is perfectly safe.
//
// 3)
// {"S"}
//
// Returns: 0
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
