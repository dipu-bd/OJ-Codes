/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
//#include <bits/stdc++.h>
//C headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
//cpp headers
#include <iostream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <deque>
#include <list>
#include <bitset>
using namespace std;
//typedefs
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vii;
typedef vector<pii> vpii;
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define memsz(a,b,n) memset(a, b, n * sizeof(*a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
//io
#define sf scanf
#define pf printf
#define sf1(a) scanf("%d", &a)
#define sf2(a, b) scanf("%d %d", &a, &b)
#define sf3(a, b, c) scanf("%d %d %d", &a, &b, &c);
#define sf4(a, b, c, d) scanf("%d %d %d %d", &a, &b, &c, &d);
#define debug1(a) cout << a << endl
#define debug2(a,b) cout << a << " " << b << endl
#define debug3(a,b,c) cout << a << " " << b << " " << c << endl
#define debug4(a,b,c,d) cout << a << " " << b << " " << c << " " << d << endl
//useful with graphs
#define fr first
#define sc second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define ins insert
#define IT iterator
#define allof(v) v.begin(), v.end()
#define ssort(v) stable_sort(v.begin(), v.end())
#define LB lower_bound
#define UB upper_bound
#define POPC __builtin_popcount
#define loop(i, x) for(__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)
#define rloop(i, x) for(__typeof((x).rbegin()) i=(x).rbegin(); i!=(x).rend(); ++i)
//variables and functions
const double PI = 2.0 * acos(0.0);
const double EXP1 = exp(1);
template<typename T> inline T sqr(T n) { return n * n; }
inline double hypot(double x, double y) { return sqrt(sqr(x) + sqr(y)); }
template<typename T> inline T pmod(T n, T m) { return ((n % m) + m) % m; }
template<typename T> T power(T n, int p) { return (p == 0) ? (T)(1) : (sqr(power(n, p >> 1)) * ((p & 1) * (n - 1) + 1)); }
template<typename T> T bigmod(T n, int p, T m) { return (p == 0) ? (T)(1) : ((sqr(bigmod(n, p >> 1, m)) % m) * ((p & 1) * (n - 1) % m + 1)) % m; }
/*--------------------------------------------------------------------------------*/

int sz;
char save[1048580][2];

bool recur(bitset<20> bit, bool win = 0)
{
    bit[sz - 1] = 0;
    if(bit.none()) return win;

    char& dp = save[bit.to_ulong()][win];
    if(dp != -1) return dp;

    dp = 0;
    REP(i, 1, sz)
    {
        if(!bit[i])
        {
            if(bit[i - 1])
            {
                bit[i] = 1, bit[i - 1] = 0;
                if(recur(bit, !win)) dp = 1;
                bit[i] = 0, bit[i - 1] = 1;
            }
            if(i >= 3 && bit[i - 3])
            {
                bit[i] = 1, bit[i - 3] = 0;
                if(recur(bit, !win)) dp = 1;
                bit[i] = 0, bit[i - 3] = 1;
            }
            if(dp) return dp;
        }
    }

    return dp;
}

class EllysCheckers
{
public:
    string getWinner(string board)
    {
        bitset<20> bit;
        sz = board.size();
        REP(i, 0, sz)
        {
            bit.set(i, board[i] == 'o');
        }

        mem(save, -1);
        bool win = recur(bit);
        if(win) return "YES";
        else return "NO";
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, string p1)
{
    cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
    cout << "]" << endl;
    EllysCheckers *obj;
    string answer;
    obj = new EllysCheckers();
    clock_t startTime = clock();
    answer = obj->getWinner(p0);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "\"" << p1 << "\"" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "\"" << answer << "\"" << endl;
    if (hasAnswer)
    {
        res = answer == p1;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    string p0;
    string p1;

    {
        // ----- test 0 -----
        p0 = ".o...";
        p1 = "YES";
        all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = "..o..o";
        p1 = "YES";
        all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = ".o...ooo..oo..";
        p1 = "NO";
        all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = "......o.ooo.o......";
        p1 = "YES";
        all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        p0 = ".o..o...o....o.....o";
        p1 = "NO";
        all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// Elly and Kriss play a game. The game is played on a single row that consists of N cells; we will call it the board. The cells of the board are numbered 0 through N-1, from the left to the right. Each cell of the board is either empty or occupied by a single checker. The girls take alternating turns, until one of them cannot make a move. The girl who is unable to make a move loses the game.
//
// In each move the current player selects a cell containing a checker and performs one of the following two types of moves:
//
// A step, in which the checker is moved one cell to the right. The step can only be made if the target cell is empty.
// A jump, in which the checker jumps three cells to the right. The jump can only be made if the target cell is empty and the cells it jumped over contain two other checkers.
//
// Once a checker reaches the rightmost cell, it disappears immediately and no longer plays any role in the game.
//
// The initial layout of the board will be given as a string board. The i-th character of board will be '.' (a period) if the i-th cell is empty at the
// beginning, and it will be 'o' (lowercase letter o) if the i-th cell initially contains a checker. Assume that both girls play optimally. Return "YES" (quotes for clarity) if the first player wins the game and "NO" otherwise.
//
// DEFINITION
// Class:EllysCheckers
// Method:getWinner
// Parameters:string
// Returns:string
// Method signature:string getWinner(string board)
//
//
// NOTES
// -If there is a checker on the rightmost cell in the beginning of the game, it disappears instantly (before the first move is made), as if it were never there.
// -The rules of the game ensure that each cell contains at most one checker at any time, and that no checker can jump beyond the last cell.
//
//
// CONSTRAINTS
// -board will contain between 1 and 20 characters, inclusive.
// -Each character of board will be either '.' or 'o'.
//
//
// EXAMPLES
//
// 0)
// ".o..."
//
// Returns: "YES"
//
// With only one checker it is pretty obvious who will win.
//
// 1)
// "..o..o"
//
// Returns: "YES"
//
// Don't forget to ignore checkers on the rightmost cell.
//
// 2)
// ".o...ooo..oo.."
//
// Returns: "NO"
//
// Here one can jump the checker from cell 5 to cell 8.
//
// 3)
// "......o.ooo.o......"
//
// Returns: "YES"
//
// 4)
// ".o..o...o....o.....o"
//
// Returns: "NO"
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
