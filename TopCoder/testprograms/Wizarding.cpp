/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
//#include <bits/stdc++.h>
//C headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
//cpp headers
#include <iostream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <deque>
#include <list>
//#include <bitset>
using namespace std;
//typedefs
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vii;
typedef vector<pii> vpii;
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define memsz(a,b,n) memset(a, b, n * sizeof(*a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
#define sf1(a) scanf("%d", &a)
#define sf2(a, b) scanf("%d %d", &a, &b)
#define sf3(a, b, c) scanf("%d %d %d", &a, &b, &c);
#define sf4(a, b, c, d) scanf("%d %d %d %d", &a, &b, &c, &d);
//useful with graphs
#define fr first
#define sc second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define ins insert
#define IT iterator
#define allof(v) v.begin(), v.end()
#define ssort(v) stable_sort(v.begin(), v.end())
#define LB lower_bound
#define UB upper_bound
#define POPC __builtin_popcount
#define loop(i, x) for(__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)
#define rloop(i, x) for(__typeof((x).rbegin()) i=(x).rbegin(); i!=(x).rend(); ++i)
//variables and functions
const double PI = 2.0 * acos(0.0);
const double EXP1 = exp(1);
template<typename T> inline T sqr(T n) { return n * n; }
inline double hypot(double x, double y) { return sqrt(sqr(x) + sqr(y)); }
template<typename T> inline T pmod(T n, T m) { return ((n % m) + m) % m; }
/*--------------------------------------------------------------------------------*/

const int mod = 77077;

int power;
string counter;

void backtrack(int p, string spell, string& rules)
{
    if(p == spell.size())
    {
        if(p == 0) return;

        int cnt = 1;
        REP(i, 0, p)
        {
            cnt *= spell[i] - 'A' + 1;
            cnt %= mod;
        }

        bool change = false;
        if(cnt > power) change = true;
        else if(cnt == power)
        {
            if(counter.size() > spell.size())
                change = true;
            else if(counter.size() == spell.size())
                change = (counter > spell);
        }

        if(change)
        {
            power = cnt;
            counter = spell;
        }
    }
    else
    {
        //unchange
        backtrack(p + 1, spell, rules);
        //replace
        char ch = spell[p];
        if(rules[ch - 'A'] != '-')
        {
            spell[p] = rules[ch - 'A'];
            backtrack(p + 1, spell, rules);
            spell[p] = ch;
        }
        //delte
        spell.erase(spell.begin() + p);
        backtrack(p, spell, rules);
    }
}

class Wizarding
{
public:
    string counterspell(string spell, string rules)
    {
        power = 0;
        counter = "";
        backtrack(0, spell, rules);
        return counter;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2)
{
    cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
    cout << "]" << endl;
    Wizarding *obj;
    string answer;
    obj = new Wizarding();
    clock_t startTime = clock();
    answer = obj->counterspell(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "\"" << p2 << "\"" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "\"" << answer << "\"" << endl;
    if (hasAnswer)
    {
        res = answer == p2;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    string p0;
    string p1;
    string p2;

    {
        // ----- test 0 -----
        p0 = "AA";
        p1 = "Z-------------------------";
        p2 = "ZZ";
        all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = "AB";
        p1 = "ZS------------------------";
        p2 = "ZS";
        all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = "ZZZZ";
        p1 = "-------------------------Z";
        p2 = "ZZZZ";
        all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = "ABCDE";
        p1 = "ZYXXYXZZXYXXZZXZYYXZZZX---";
        p2 = "ZXXE";
        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        p0 = "ABCDEABCDEABC";
        p1 = "ACBDESKADSLOEDDDASDBADEDAE";
        p2 = "CCDECCECC";
        all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// A spell is defined by its incantation, the word spoken when the spell is being cast. If you know the incantation of a spell, you can create counterspells in the following manner. First, you can optionally delete any number of characters from the original incantation. Note that empty incantations are not valid so you cannot delete all characters. Then, you can replace any number of the remaining characters according to a set of replacement rules. The replacement rules tell you which letters can be replaced, and the letters with which they can be replaced. For example, if the original incantation is "AA" and the allowed replacement is 'A' to 'Z', the following counterspells are possible: "AA", "A", "Z", "ZZ", "AZ", "ZA".
//
// The best counterspell is the one with the greatest power. The power of a spell is the product of all its character values modulo 77077, where the value for a character is its position in the alphabet (character 'A' has value 1, character 'B' value 2, character 'C' value 3, and so on). The best possible counterspell for "AA" in the example above is "ZZ", which has a power of 676.
//
//
// Please note that if the allowed replacements are 'A' to 'B' and 'B' to 'C', the counterspell for "AB" is "BC" not "CC". You cannot change a character that has already been changed, even if it would lead to a more powerful spell.
//
//
// You will be given a string spell, the incantation of the spell you are going to counter, and a string rules, the allowed replacements for letters. The first character in rules is the allowed replacement for the letter 'A', the second for 'B' and so on. The character '-' is used to denote a letter that cannot be replaced. Your program must return a string, the most powerful counterspell available. If multiple return values are possible, return the shortest among them. If a tie still exists return the lexicographically earliest.
//
// DEFINITION
// Class:Wizarding
// Method:counterspell
// Parameters:string, string
// Returns:string
// Method signature:string counterspell(string spell, string rules)
//
//
// CONSTRAINTS
// -spell will contain between 1 and 13 characters, inclusive.
// -spell will contain only uppercase letters ('A'-'Z').
// -rules will contain exactly 26 characters.
// -rules will contain only uppercase letters ('A'-'Z') and dashes ('-').
//
//
// EXAMPLES
//
// 0)
// "AA"
// "Z-------------------------"
//
// Returns: "ZZ"
//
// The example from the problem statement.
//
// 1)
// "AB"
// "ZS------------------------"
//
// Returns: "ZS"
//
// The possible counterspells are "AB", "A", "B", "Z", "S", "ZB", "AS" and "ZS".
// "ZS" is the most powerful.
//
// 2)
// "ZZZZ"
// "-------------------------Z"
//
// Returns: "ZZZZ"
//
// 3)
// "ABCDE"
// "ZYXXYXZZXYXXZZXZYYXZZZX---"
//
// Returns: "ZXXE"
//
// 4)
// "ABCDEABCDEABC"
// "ACBDESKADSLOEDDDASDBADEDAE"
//
// Returns: "CCDECCECC"
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
