/*============================
 /\u7h0r : 5ud!p70 ch@ndr@ d@5
 =============================*/
//#include <bits/stdc++.h>
//C headers
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
//cpp headers
#include <iostream>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <deque>
#include <list>
//#include <bitset>
using namespace std;
//typedefs
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vii;
typedef vector<pii> vpii;
//always useful
#define gcd(a,b) __gcd(a,b)
#define clr(a) memset(a, 0, sizeof(a))
#define mem(a,b) memset(a, b, sizeof(a))
#define memsz(a,b,n) memset(a, b, n * sizeof(*a))
#define REP(i, a, n) for(int i = a; i < n; ++i)
#define REPE(i, a, n) for(int i = a; i <= n; ++i)
#define RREP(i, a, n) for(int i = a; i > n; --i)
#define RREPE(i, a, n) for(int i = a; i >= n; --i)
#define sf1(a) scanf("%d", &a)
#define sf2(a, b) scanf("%d %d", &a, &b)
#define sf3(a, b, c) scanf("%d %d %d", &a, &b, &c);
#define sf4(a, b, c, d) scanf("%d %d %d %d", &a, &b, &c, &d);
//useful with graphs
#define fr first
#define sc second
#define pb push_back
#define pp pop_back
#define mp make_pair
#define ins insert
#define IT iterator
#define allof(v) v.begin(), v.end()
#define ssort(v) stable_sort(v.begin(), v.end())
#define LB lower_bound
#define UB upper_bound
#define POPC __builtin_popcount
#define loop(i, x) for(__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)
#define rloop(i, x) for(__typeof((x).rbegin()) i=(x).rbegin(); i!=(x).rend(); ++i)
//variables and functions
const double PI = 2.0 * acos(0.0);
const double EXP1 = exp(1);
template<typename T> inline T sqr(T n) { return n * n; }
inline double hypot(double x, double y) { return sqrt(sqr(x) + sqr(y)); }
template<typename T> inline T pmod(T n, T m) { return ((n % m) + m) % m; }
/*--------------------------------------------------------------------------------*/


char out[100][100];
vector<string> res;

void make(int n)
{
    mem(out, ' ');

    int l = 0, r = n - 1;
    int u = 0, d = n - 1;
    while(l <= r)
    {
        REPE(i, l, r)
        {
            out[u][i] = '#';
            out[d][i] = '#';
        }
        REPE(i, u, d)
        {
            out[i][l] = '#';
            out[i][r] = '#';
        }
        l += 2;
        r -= 2;
        u += 2;
        d -= 2;
    }

    REP(i, 0, n)
    {
        out[i][n] = 0;
        res.pb(out[i]);
    }
}

class Target {
public:
	vector <string> draw(int n) {
        res.clear();
        make(n);
        return res;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << p0;
	cout << "]" << endl;
	Target *obj;
	vector <string> answer;
	obj = new Target();
	clock_t startTime = clock();
	answer = obj->draw(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{\n ";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"" << endl;
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{\n ";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"" << endl;
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	int p0;
	vector <string> p1;

	{
	// ----- test 0 -----
	p0 = 5;
	string t1[] = {"#####","#   #","# # #","#   #","#####"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = 9;
	string t1[] = {"#########","#       #","# ##### #","# #   # #","# # # # #","# #   # #","# ##### #","#       #","#########"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = 13;
	string t1[] = {"#############","#           #","# ######### #","# #       # #","# # ##### # #","# # #   # # #","# # # # # # #","# # #   # # #","# # ##### # #","# #       # #","# ######### #","#           #","#############"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = 17;
	string t1[] = {"#################","#               #","# ############# #","# #           # #","# # ######### # #","# # #       # # #","# # # ##### # # #","# # # #   # # # #","# # # # # # # # #","# # # #   # # # #","# # # ##### # # #","# # #       # # #","# # ######### # #","# #           # #","# ############# #","#               #","#################"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Here at [topcoder], we call a contestant a "target" if their rating is 3000 or more.
// In the arena, the targets have a red icon with a small target on it.
// Do you want to become a target as well?
// Sure you do.
// But before you get there, let's start with something easier: drawing a target.
//
//
//
// The target you need to draw consists of nested squares.
// The innermost square is just a single '#' character.
// The larger squares use alternatingly the character ' ' (space) and the character '#'.
// Here is an example in which the side of the largest square is n = 5:
//
//
//
//
// #####
// #   #
// # # #
// #   #
// #####
//
//
//
// And here is an example for n = 9:
//
//
//
// #########
// #       #
// # ##### #
// # #   # #
// # # # # #
// # #   # #
// # ##### #
// #       #
// #########
//
//
//
//
// You will be given an int n.
// Your method must return a vector <string> which contains a drawing of the target with side n.
// More precisely, each element of the returned vector <string> must be one row of the drawing, in order.
// Therefore, the returned vector <string> will consist of n elements, each with n characters.
// (See the examples below for clarification.)
//
//
//
// The value of n will be such that a target like the ones above can be drawn: 5, 9, 13, and so on.
// Formally, n will be of the form 4k+1, where k is a positive integer.
//
// DEFINITION
// Class:Target
// Method:draw
// Parameters:int
// Returns:vector <string>
// Method signature:vector <string> draw(int n)
//
//
// CONSTRAINTS
// -n will be between 5 and 49, inclusive.
// -n mod 4 will be 1.
//
//
// EXAMPLES
//
// 0)
// 5
//
// Returns: {"#####", "#   #", "# # #", "#   #", "#####" }
//
//
//
// 1)
// 9
//
// Returns: {"#########", "#       #", "# ##### #", "# #   # #", "# # # # #", "# #   # #", "# ##### #", "#       #", "#########" }
//
//
//
// 2)
// 13
//
// Returns: {"#############", "#           #", "# ######### #", "# #       # #", "# # ##### # #", "# # #   # # #", "# # # # # # #", "# # #   # # #", "# # ##### # #", "# #       # #", "# ######### #", "#           #", "#############" }
//
//
//
// 3)
// 17
//
// Returns: {"#################", "#               #", "# ############# #", "# #           # #", "# # ######### # #", "# # #       # # #", "# # # ##### # # #", "# # # #   # # # #", "# # # # # # # # #", "# # # #   # # # #", "# # # ##### # # #", "# # #       # # #", "# # ######### # #", "# #           # #", "# ############# #", "#               #", "#################" }
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
